# -*- coding: utf-8 -*-
"""Percolation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qzMNUUI8qjMjmnvfZ_8-f4RaVmiFJ711
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import style
import matplotlib.colors as mcolors
style.use('ggplot')

"""# **1.Percolation**"""

#first part of this question is fairly simple,i will make a function to return resulting matrix(filled with 0s and 1s)

def Percolation(L,p):
  matrix=np.random.rand(L,L)
  return (matrix<=p).astype(bool)

#lets check how it works
mat=Percolation(2,0.5)
cmap=mcolors.ListedColormap(['blue','red'])#i represent 0s with blue and 1s with red
plt.matshow(mat,cmap=cmap)
plt.grid(False)
plt.show()
mat

#now i make a function that calculate the resulting matrix has transverse percolation or not,here i used Depth-First Search (DFS) algorithm,it is one of the common graph algorithm for this kind of questions
def can_traverse_matrix(matrix):
    rows = len(matrix)
    cols = len(matrix[0])

    for i in range(rows):
        if matrix[i][0] == 1:
            if dfs(matrix, i, 0, set()):
                return 1
    return 0


def dfs(matrix, row, col, visited):
    rows = len(matrix)
    cols = len(matrix[0])

    if col == cols - 1:
        return True

    visited.add((row, col))
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for dr, dc in directions:
        new_row, new_col = row + dr, col + dc
        if (0 <= new_row < rows and 0 <= new_col < cols and
            matrix[new_row][new_col] == 1 and
            (new_row, new_col) not in visited):
            if dfs(matrix, new_row, new_col, visited):
                return True

    visited.remove((row, col))
    return False


print(can_traverse_matrix(mat))#here you can see it algorithm works!

mat=Percolation(10,0.6)
plt.matshow(mat,cmap=cmap)
plt.grid(visible=False)
plt.show()
can_traverse_matrix(mat)