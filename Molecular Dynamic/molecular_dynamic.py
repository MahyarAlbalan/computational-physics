# -*- coding: utf-8 -*-
"""Molecular Dynamic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1boOYbqzTPUN2SeUzas8mrSMatTAN4oM3
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('whitegrid')

N = 100
L = 200
r = 1 #sigma in lennard-jones intraction
positions = np.zeros((N,2),dtype=float)

#now lets fix initial positions.
ncols = np.floor(np.sqrt(N/2))
nrows = 2 * ncols
a = L / (2 * ncols)#distance between atoms

for n in range(N):
  positions[n, 0] = r + n // nrows * a
  positions[n, 1] = r + n % nrows * a

plt.scatter(positions[:,0], positions[:, 1], s = 10)
plt.xlim(0,200)
plt.ylim(0,200)
plt.grid(False)
plt.show()

#now i will set initial velocities based on total energy of particles E
E = 200
m = 1
np.random.seed(7)
vavg = (2 * E / (m * N)) ** 0.5
vmax = 2 * vavg
v = np.random.randn(N) * vmax
theta = np.random.rand() * 2 * np.pi
velocities = np.c_[v * np.cos(theta), v * np.sin(theta)]

#now i will write a function that will calculate acceleration of each particle with lennard-jones intractions
def lj(positions, N, e=1):
  a = np.zeros((N,2))
  for n in range(N):
    others = np.vstack((positions[0:n], positions[n+1 :]))
    delta = others - positions[n]
    distance = (np.sum(delta ** 2, axis = 1) ** 0.5).reshape(-1,1)
    a[n] = np.sum(4 * e * (12 * delta / distance ** 14 - 6 * delta / distance ** 8), axis = 0) / m

  return a
a = (positions, N)
a

#now we have accelarations based on positions so i can go on and calculate dynamic of system in fixed intervals

