# -*- coding: utf-8 -*-
"""Ising Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mh9UHKLHX32bcD0mEw6s80-t3lIJyUV9
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import style
from matplotlib import colors
import seaborn as sns
style.use('seaborn-v0_8-paper')

"""# **I.2D Ising Model**"""

#lets do step by step as mentioned in the text
class IsingModel:

  def __init__(self, netsize, available_spins, J, T):
    '''
    in this function i just create, network and save some of the related parameters such as T and J
    '''
    if isinstance(netsize, int):
      self.L_ = netsize
      self.net_ = np.random.choice(available_spins, size = (netsize, netsize))
    else:
      self.L_ = netsize.shape[0]
      self.net_ = netsize.copy()
    self.T_ = T
    self.spins_ = available_spins
    self.j_ = J
    self.J_ = J / (T)#i put k_b = 1
    delta_E = np.array([-8, -4, 0, 4, 8])
    self.values_ = {i : np.exp(-i * self.J_) for i in delta_E}
    self.magnetization_history = []




  def energy(self):
    '''
    here i calculate E for given network structure with periodic boundry condition,
    for summing all the intractions i used the same logic we used in coloring algorithm
    for counting each intraction exactly once.this is more efficient than summing
    all four neighbors and divide the result by 2.
    '''
    L = self.net_.shape[0]
    E = 0

    for i in range(L):
      for j in range(L):
        E += (self.net_[(i+1) % L, j] + self.net_[i, (j+1) % L]) * self.net_[i, j]

    return -self.j_ * E



  def delta_E(self, i, j):
    '''
    here i calculate delta E
    '''
    #i, j = np.random.randint(0, self.net_.shape[0], size = 2)
    delta = 2* self.net_[i, j] * (self.net_[(i + 1) % self.L_, j] + self.net_[(i - 1) % self.L_, j] + self.net_[i, (j + 1) % self.L_] + self.net_[i, (j - 1) % self.L_] )

    return delta


  def MCstep(self, N, s, want_visual):
    '''
    here i perform Monte Carlo step N times and i display changes in system at each
    s steps.
    '''
    if want_visual:
      plt.figure(figsize=(6,6))

    for n in range(N):
      i , j = np.random.randint(0, self.net_.shape[0], size = 2)
      dE = self.delta_E(i, j)

      if dE <= 0 or np.random.rand() < self.values_[dE]:
        self.net_[i, j] *= -1

      self.magnetization_history.append(np.abs( np.mean( self.net_)))

      if want_visual:
        if (n+1) % s == 0 :
          plt.clf()
          cmap = colors.ListedColormap(['red', 'blue'])
          plt.matshow(self.net_, cmap=cmap)
          plt.title(f'Step {n}/{N}, Energy={self.energy():.2f}, M={self.magnetization_history[-1]}, T = {self.T_:.2f}')
          plt.colorbar(ticks=[-1, 1])
          plt.pause(0.01)
          plt.show()

    self.m_avg = np.mean(self.magnetization_history)

T = np.arange(100, 0.1, -0.1)
net= np.random.choice([-1, 1], size = (10, 10))#initial network
m = []
k = 0
for t in T:
  I = IsingModel(net, [-1, 1], 1, t)
  if k % 5 == 0:
    I.MCstep(200, 200, True)#i will display the result after changing temp
    k += 1
  else:
    I.MCstep(200, 200, False)
    k += 1
  m.append(I.m_avg)
  net = I.net_
#as expected

#now lets plot average M vs 1/T
plt.figure(figsize=(8, 6))
plt.xlabel('1/T')
plt.ylabel('M')
sns.lineplot(x= 1/T, y= m)
plt.grid(True)
plt.show()
#as expected in low tempreture all spins are in the same direction!so total magnetization is 1 as expected