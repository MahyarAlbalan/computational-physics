# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18sD8LrfvSd6BuD_VpzEs77L9dhOYVk_e

# **fractals problems**
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import style
style.use('seaborn-v0_8')

"""Creating Koch fractal.
I crate this fractal using 4,functions:

one will do transformation.

one will do rotation as much as e want!(we can write two functions for rotation,60 degrees rotation and -60 degrees rotation;but for generalization i will write a function to perform arbitrary rotation)

last function will put toghether these functions and create the fractal.
"""

def transform(x,a):
  return x+a
def rotate(x,theta):
  rotation_matrix=np.array([[np.cos(theta),-np.sin(theta)],[np.sin(theta),np.cos(theta)]])
  return np.dot(rotation_matrix,x)

#now that we have built the basic functions lets make the fractal

def koch(x,n):
  for i in range(n):
    #for k in range(len(x)):
    x=x/3#for scaling
    x2=rotate(x.T,np.pi/3).T
    x2=transform(x2,x[-1])
    #lets create the other one
    x3=rotate(x.T,-np.pi/3).T
    x3=transform(x3,x2[-1])
    #now lets craete the right tail
    x4=transform(x,x3[-1])
    x=np.vstack((x,x2,x3,x4))

  plt.plot(x[:,0],x[:,1],color='black',marker=None)
  plt.axis('equal')
  plt.title(f'Koch Curve-order {n}')
  plt.show()

x_init = np.array([[0, 0], [1, 0]])
koch(x_init, 0)
koch(x_init, 1)
koch(x_init, 2)
koch(x_init, 3)
koch(x_init, 5)
koch(x_init, 8)
koch(x_init, 10)

x_init = np.array([[0, 0],[1,1],[2,0]])
koch(x_init, 10)

#now i use the koch function to create whole snowflake
def koch(x,n):
  for i in range(n):
    #for k in range(len(x)):
    x=x/3#for scaling
    x2=rotate(x.T,np.pi/3).T
    x2=transform(x2,x[-1])
    #lets create the other one
    x3=rotate(x.T,-np.pi/3).T
    x3=transform(x3,x2[-1])
    #now lets craete the right tail
    x4=transform(x,x3[-1])
    x=np.vstack((x,x2,x3,x4))

  return x


x_init = np.array([[0, 0],[1,1],[2,0]])
x=koch(x_init, 10)
x_reflect=x.copy()
x_reflect[:,1]=-x[:,1]
plt.plot(x[:,0],x[:,1],color='black')
plt.plot(x_reflect[:,0],x_reflect[:,1],color='black')
plt.axis('off')

plt.title(f'Koch Snowflake-order {10}')
plt.show()

"""now lets make Heighway Dragon!
i will create it using two function,first function for rotation and onother one for reflection!
"""

def rotate_scale(theta,scale,x):
  rotation_matrix=np.array([[np.cos(theta),-np.sin(theta)],[np.sin(theta),np.cos(theta)]])
  r=x[1]-x[0]
  r = (x[1] - x[0]) @ rotation_matrix.T
  r=r*scale
  r=r+x[0]
  return r


def Heighway(n,x):
  y=x.copy()
  for k in range(n):
    a=np.array([x[0]])

    for i in range(len(x)-1):
      if i%2==0:
        new_point=rotate_scale(np.pi/4,1/np.sqrt(2),x[i:i+2])
      else:
        new_point=rotate_scale(-np.pi/4,1/np.sqrt(2),x[i:i+2])
      a = np.vstack((a,new_point,x[i + 1]))
    x=a

  plt.plot(x[0:len(x)//2+1, 0], x[0:len(x)//2+1, 1], color='blue', linewidth=1.5)
  plt.plot(x[len(x)//2:, 0], x[len(x)//2:, 1], color='red', linewidth=1.5)
  plt.title(f'Heighway Dragon Fractal - Order {n}')
  plt.axis("off")
  plt.show()

x= np.array([[0, 0], [1, 0]])
Heighway(1,x)
Heighway(2,x)
Heighway(3,x)
Heighway(4,x)
Heighway(6,x)
Heighway(10,x)
Heighway(15,x)
Heighway(17,x)

"""now lets create Sierpinski fractal"""

def translate(x,r):
  return x+r


def Sierpinski(n,x):

  for i in range(n):
    x1=x/2
    x2=translate(x1,np.array([1/2,np.sqrt(3)/2]))
    x3=translate(x1,np.array([1,0]))
    x=np.vstack((x1,x2,x3))

  for k in range(0, len(x),3):
      plt.fill(x[k:k+3, 0], x[k:k+3, 1], color='blue', alpha=1)

  plt.title(f'Sierpinski Fractal - Order {n}')
  plt.axis('off')
  plt.show()
a=np.array([[0,0],[1,np.sqrt(3)],[2,0]],dtype=np.float64)
Sierpinski(1,a)
Sierpinski(2,a)
Sierpinski(3,a)
Sierpinski(5,a)
Sierpinski(8,a)

"""*Khayyam-Pascal's Triangle *"""

from scipy.special import comb
def khayyam_pascal(n):
    t=np.zeros((n,n))
    for i in range(n):

        for j in range(i+1):
            t[i,j]=(comb(i, j, exact=True) % 2)
        t[i]=np.roll(t[i],shift=(n-1-i)//2)#i kinda adjust the triangle here!
    return t
#the top function will create khayyam_pascal triangle and because we want to plot the result based on odd and even numbers,i mark them by 0(even) and 1(odd)

a=khayyam_pascal(1000)
plt.imshow(a,cmap='binary')
plt.title('khayyam_pascal triangle')
plt.axis('off')
plt.show()
#Wow, what a suprise!it just looks like seirpinski triangle!but its run time is fairly lower than the code for creating sierpinski's triangle!

"""Creating sierpinski triangle using random generator

I performed 3 steps to create sierpinski's triangle

first one will scale the whole shape by factor of 1/2

second and third ones will transform the scaled shape,and Union of all these functions will create sierpiski's triangle.
"""

def rand_Sierpinski(n,p):
  x=np.column_stack((np.random.uniform(0,2,n),np.random.uniform(0,np.sqrt(3),n)))

  for i in range(p):
    c=np.random.randint(0,3,n)#here i used vectorized calculation with numpy array and delete one of the loops(that one which was iterating through all n points)
    translations = np.array([[0,0],[0.5,np.sqrt(3)/2],[1,0]])
    x=x*0.5+translations[c]

  plt.scatter(x[:,0],x[:,1],s=0.05,marker='.',c='black')
  plt.title(f'Sierpinski triangle with {n} points')
  plt.axis('off')
  plt.show()


rand_Sierpinski(1000,100)
rand_Sierpinski(1000,1000)
rand_Sierpinski(5000,1000)
rand_Sierpinski(10000,1000)
rand_Sierpinski(100000,1000)
rand_Sierpinski(1000000,1000)

"""now lets generate Fern leaf fractal.

here there are 4 generator function

first one will scale the original shape by factor 0.84 then rotates by -0.05 rad and then translate [0,0.16] (if we consider y axis range is from 0 to 2)(result in light blue shape in the lecture)

second one will scale by factor 0.34,then rotates by 0.68 rad,then translate by [0,0.16](this will result in red rectangular in the lacture)

in the third one original shape reflects by y axis,then scale by 0.42 and then rotate by -0.6 rad,then translate by [0,0.055]

in the last one for stem transformation which it does the transformation [0,0.16*y]
"""

def Fern_leaf(n,p):
  x=np.column_stack((np.random.uniform(-0.5,0.5,n),np.random.uniform(0,2,n)))
  translations = [lambda x: 0.84*(np.dot(np.array([[np.cos(-0.05),-np.sin(-0.05)],[np.sin(-0.05),np.cos(-0.05)]]),x))+np.array([0,0.16]),
                  lambda x: 0.42*(np.dot(np.array([[np.cos(-0.6),-np.sin(-0.6)],[np.sin(-0.6),np.cos(-0.6)]]),np.dot(np.array([[-1,0],[0,1]]),x)))+np.array([0,0.055]),
                  lambda x: 0.34*(np.dot(np.array([[np.cos(0.68),-np.sin(0.68)],[np.sin(0.68),np.cos(0.68)]]),x))+np.array([0,0.16]),
                  lambda x: np.array([0, 0.16*x[1]])

                  ]

  for i in range(p):
    c=np.random.randint(0,4,n)#here  again i used vectorized calculation with numpy array and delete one of the loops(that one which was iterating through all n points)
    x=np.array([translations[j](x[i]) for i,j in enumerate(c)])
  plt.scatter(x[:,0],x[:,1],s=0.1,marker='.',c='green')
  plt.title(f'Fern_leaf with {n} points')
  plt.axis('off')
  plt.show()


Fern_leaf(10000,100)
Fern_leaf(100000,50)
Fern_leaf(1000000,50)

"""after reading about Barnsley Fern fractal i understand that probabilities for each translation are not the same, it probablities are:

main transformation (85%)

Left leaf transformation (7%)

Right leaf transformation (7%)

Stem transformation (2%)

so lets correct the code based on these probablities.
"""

def Fern_leaf(n,p):
  x=np.column_stack((np.random.uniform(-0.5,0.5,n),np.random.uniform(0,2,n)))
  translations = [lambda x: 0.84*(np.dot(np.array([[np.cos(-0.05),-np.sin(-0.05)],[np.sin(-0.05),np.cos(-0.05)]]),x))+np.array([0,0.16]),
                  lambda x: 0.42*(np.dot(np.array([[np.cos(-0.6),-np.sin(-0.6)],[np.sin(-0.6),np.cos(-0.6)]]),np.dot(np.array([[-1,0],[0,1]]),x)))+np.array([0,0.055]),
                  lambda x: 0.34*(np.dot(np.array([[np.cos(0.68),-np.sin(0.68)],[np.sin(0.68),np.cos(0.68)]]),x))+np.array([0,0.16]),
                  lambda x: np.array([0, 0.16*x[1]])

                  ]

  for i in range(p):
    c=np.random.choice(4,size=n,p=[0.84,0.07,0.07,0.02])#here  again i used vectorized calculation with numpy array and delete one of the loops(that one which was iterating through all n points)
    x=np.array([translations[j](x[i]) for i,j in enumerate(c)])
  plt.scatter(x[:,0],x[:,1],s=0.05,marker='.',c='green')
  plt.title(f'Fern_leaf with {n} points')
  plt.axis('off')
  plt.show()


Fern_leaf(10000,100)
Fern_leaf(100000,50)
Fern_leaf(1000000,50)

"""**Julia Set**"""

def julia(c,iteration=100):
  a=np.linspace(-2,2,4000)#i could choose lower number of points for better runtime,but this is good and doesnt take too long.
  b=np.linspace(-2,2,4000)
  a,b=np.meshgrid(a,b)
  x=a+1j*b
  #now i will create a mask for saving time and apply function each time only to the points that are still in the bound
  m=np.ones(x.shape,dtype=bool)
  counter=np.zeros(m.shape,dtype=np.uint16)

  for i in range(iteration):
    x[m]=x[m]**2+c
    m= m&(np.abs(x)<3)
    counter[m]=i#counting how many time we should apply function to the point so it goes out of the bound
  plt.figure(facecolor='black')
  plt.imshow(counter,cmap="inferno",extent=(-2, 2, -2, 2))
  plt.axis('off')
  plt.title(label=f'Julia set with c={c}',color='white')
  plt.show()

julia(c=complex(0,-1))
julia(c=-0.4-1j*0.6)
julia(c=-0.6)
julia(c=-0.12-1j*0.75)
julia(c=-0.4+1j*0.6)
julia(c=-0.8+1j*0.16)
julia(c=-np.pi/4)
julia(c=-1j*np.pi/4)
julia(c=-np.pi/4-1j*np.pi/4)