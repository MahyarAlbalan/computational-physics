# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18sD8LrfvSd6BuD_VpzEs77L9dhOYVk_e

# **fractals problems**
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import style
style.use('seaborn-v0_8')

"""Creating Koch fractal.
I crate this fractal using 4,functions:

one will do transformation.

one will do rotation as much as e want!(we can write two functions for rotation,60 degrees rotation and -60 degrees rotation;but for generalization i will write a function to perform arbitrary rotation)

last function will put toghether these functions and create the fractal.
"""

def transform(x,a):
  return x+a
def rotate(x,theta):
  rotation_matrix=np.array([[np.cos(theta),-np.sin(theta)],[np.sin(theta),np.cos(theta)]])
  return np.dot(rotation_matrix,x)

#now that we have built the basic functions lets make the fractal

def koch(x,n):
  for i in range(n):
    #for k in range(len(x)):
    x=x/3#for scaling
    x2=rotate(x.T,np.pi/3).T
    x2=transform(x2,x[-1])
    #lets create the other one
    x3=rotate(x.T,-np.pi/3).T
    x3=transform(x3,x2[-1])
    #now lets craete the right tail
    x4=transform(x,x3[-1])
    x=np.vstack((x,x2,x3,x4))

  plt.plot(x[:,0],x[:,1],color='black',marker=None)
  plt.xlim()
  plt.ylim(bottom=-.2,top=1)
  plt.title(f'Koch Curve-order {n}')
  plt.show()

x_init = np.array([[0, 0], [1, 0]])

koch(x_init, 10)

#now lets pass a traingle
x_init = np.array([[0, 0],[1,1],[2,0]])
koch(x_init, 10)

"""now lets make Heighway Dragon!
i will create it using two function,first function for rotation and onother one for reflection!
"""

def rotate_scale(theta,scale,x):
  rotation_matrix=np.array([[np.cos(theta),-np.sin(theta)],[np.sin(theta),np.cos(theta)]])
  r=x[1]-x[0]
  r = (x[1] - x[0]) @ rotation_matrix.T
  r=r*scale
  r=r+x[0]
  return r


def Heighway(n,x):
  y=x.copy()
  for k in range(n):
    a=np.array([x[0]])

    for i in range(len(x)-1):
      if i%2==0:
        new_point=rotate_scale(np.pi/4,1/np.sqrt(2),x[i:i+2])
      else:
        new_point=rotate_scale(-np.pi/4,1/np.sqrt(2),x[i:i+2])
      a = np.vstack((a,new_point,x[i + 1]))
    x=a

  plt.plot(x[0:len(x)//2+1, 0], x[0:len(x)//2+1, 1], color='blue', linewidth=1.5)
  plt.plot(x[len(x)//2:, 0], x[len(x)//2:, 1], color='red', linewidth=1.5)
  plt.title(f'Heighway Dragon Fractal - Order {n}')
  plt.axis("equal")
  plt.show()

x= np.array([[0, 0], [1, 0]])
Heighway(1,x)
Heighway(2,x)
Heighway(3,x)
Heighway(4,x)
Heighway(6,x)
Heighway(10,x)
Heighway(15,x)
Heighway(17,x)

"""now lets create Sierpinski fractal"""

def translate(x,r):
  return x+r


def Sierpinski(n,x):

  for i in range(n):
    x1=x/2
    x2=translate(x1,np.array([1/2,np.sqrt(3)/2]))
    x3=translate(x1,np.array([1,0]))
    x=np.vstack((x1,x2,x3))

  for k in range(0, len(x),3):
      plt.fill(x[k:k+3, 0], x[k:k+3, 1], color='blue', alpha=1)

  plt.title(f'Sierpinski Fractal - Order {n}')
  plt.show()
a=np.array([[0,0],[1,np.sqrt(3)],[2,0]],dtype=np.float64)
Sierpinski(1,a)
Sierpinski(2,a)
Sierpinski(3,a)
Sierpinski(5,a)
Sierpinski(8,a)

"""*Khayyam-Pascal's Triangle *"""

from scipy.special import comb
def khayyam_pascal(n):
    t=np.zeros((n,n))
    for i in range(n):

        for j in range(i+1):
            t[i,j]=(comb(i, j, exact=True) % 2)
        t[i]=np.roll(t[i],shift=(n-1-i)//2)#i kinda adjust the triangle here!
    return t
#the top function will create khayyam_pascal triangle and because we want to plot the result based on odd and even numbers,i mark them by 0(even) and 1(odd)

a=khayyam_pascal(1000)
plt.imshow(a,cmap='binary')
plt.title('khayyam_pascal triangle')
plt.show()
#Wow, what a suprise!it just looks like seirpinski triangle!but its run time is fairly lower than the code for creating sierpinski's triangle!