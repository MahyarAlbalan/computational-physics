# -*- coding: utf-8 -*-
"""Random Walk.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UmlBGJj7_eS8n7nuvhFAUjGtqUhknJyg
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import style
style.use('seaborn-v0_8-paper')

"""# **2.1D Random Walk**"""

def random_walk(steps=1000, p=0.5):
  arr = np.random.choice([-1,1], steps, p=[1-p, p])
  arr = np.cumsum(arr)
  return arr

#now lets create 10000 random walks and plot the <x> vs time and \sigma vs time
def calculations(step=1000, walkers=1000, p=0.5):
  xbar = np.zeros(shape = step, dtype= np.float64)
  x2 = np.zeros(shape = step, dtype= np.float64)

  for i in range(walkers):
    arr = random_walk(step, p)
    xbar += arr
    x2 += arr**2

  xbar /= walkers
  sigma = x2/walkers - xbar**2
  return xbar, sigma

step = 10000
xbar, sigma = calculations(step, 10000, 0.75)
time = np.arange(1, step+1)
plt.scatter(time, xbar, c='b', marker='.',s=1)
plt.xlabel('Time')
plt.ylabel('<x>')
plt.show()
plt.scatter(time, sigma, c='b',marker='.',s=1)
plt.xlabel('Time')
plt.ylabel('$\sigma^2$')
plt.show()

from sklearn.linear_model import LinearRegression

model = LinearRegression()
model.fit(time.reshape(-1,1), xbar)
print(f'for P=0.75 slope is {model.coef_[0]}')
#we expect for p=0.75 slope be = 0.75- 0.25 = 0.5

model.fit(time.reshape(-1,1), sigma)
print(f'for P=0.75 slope is {model.coef_[0]}')
#we expect for p=0.75 slope be = 4*0.75*0.25 = 0.75

#now lets see the plots for p=0.5

xbar, sigma = calculations(step, 10000)
time = np.arange(1, step+1)
plt.scatter(time, xbar, c='b', marker='.',s=1)
plt.xlabel('Time')
plt.ylabel('<x>')
plt.show()
plt.scatter(time, sigma, c='b',marker='.',s=1)
plt.xlabel('Time')
plt.ylabel('$\sigma^2$')
plt.show()

model.fit(time.reshape(-1,1), xbar)
print(f'for P=0.5 slope is {model.coef_[0]}')
#we expect for p=0.5 slope be = 0.5- 0.5=0
model.fit(time.reshape(-1,1),sigma)
print(f'for P=0.5 slope is {model.coef_[0]}')
#we expect for p=0.5 slope be = 4*0.5*0.5=1

"""# **3.Random Walk with boundry Conditions**"""

#here i will use random_walk function again and make anothe function to apply boundry conditions
from matplotlib.colors import ListedColormap
import seaborn as sns

def random_walk_lifespan(steps=10000, walkers=10000, p=0.5, right_boundry= -10, left_boundry=10):
  lifespan = np.zeros(shape=(walkers,2), dtype =np.float64)#saving lifespan and which boundry particle hits.
  for i in range(walkers):
    arr = random_walk(steps,p)
    l = np.argmax(arr == left_boundry) if left_boundry in arr else 999
    r= np.argmax(arr == right_boundry) if right_boundry in arr else 999
    lifespan[i] = [l, -1] if l<r else [r, 1]
  return lifespan[lifespan[:,0]!=999]



steps = 10000
walkers = 10000
lifespan = random_walk_lifespan(steps,walkers)
time = np.arange(1, len(lifespan)+1)
print(np.mean(lifespan[:,0]))#We can 1 to 100 ratio here aswell like was mentioned in the text


cmap = ListedColormap(['b','r'])
plt.scatter(time, lifespan[:,0], c=lifespan[:,1], cmap=cmap, marker='.',s=10)
plt.xlabel('the number of walker')
plt.ylabel('Lifespan')
plt.show()


#for better visualization first i will seperate each particle based on the boundry it hitted then plot its quantiles
left_hit = lifespan[lifespan[:, 1] == -1]
right_hit = lifespan[lifespan[:, 1] == 1]
left_quantiles = np.quantile(left_hit[:, 0], np.linspace(0, 1, 101))
left_quantiles = np.digitize(left_hit[:, 0], left_quantiles)

right_quantiles = np.quantile(right_hit[:, 0], np.linspace(0, 1, 101))
left_quantiles = np.digitize(right_hit[:, 0], right_quantiles)

sns.histplot(left_hit[:, 0], bins=100, kde=True,color='b', label='Left Boundry')
plt.ylabel(ylabel='counts')
plt.xlabel(xlabel='Lifespan')
plt.show()
sns.histplot(right_hit[:, 0], bins=100, kde=True,color='r', label='Right Boundry')
plt.ylabel(ylabel='counts')
plt.xlabel(xlabel='Lifespan')
plt.show()

starting_point = np.arange(-9,10)
avg_lifespan = np.zeros(shape = (len(starting_point)), dtype= np.float64)
probability = []

for i, position in enumerate(starting_point):
  k = 0
  total = 0
  for j in range(10000):#10000 random walk at each starting points
    arr = random_walk(10000) + position
    l = np.where(arr == -10)[0]
    r= np.where(arr ==10)[0]
    first_hit = np.inf
    if len(l) > 0:
        first_hit = min(first_hit, l[0])
    if len(r) > 0:
        first_hit = min(first_hit, r[0])
        if first_hit == r[0]:
          k += 1#number of hitting the right boundry

    if first_hit != np.inf:
      total +=1#number of all hits
      avg_lifespan[i] += first_hit
  avg_lifespan[i] /= total
  probability.append(k/total)

plt.plot(starting_point, avg_lifespan, c='b',linestyle = '--')
plt.xlabel('Starting Point')
plt.xticks(starting_point)
plt.ylabel('Average Lifespan')
plt.show()

plt.plot(starting_point, probability, c='b',linestyle = '--')
plt.xlabel('Starting Point')
plt.xticks(starting_point)
plt.yticks(np.linspace(0,1,6))
plt.ylabel('Probability of hitting right boundry')
plt.show()

"""# **4.Enumeration**"""

def probability_tabel(steps=1000, p=0.5, start=0):
  promat = np.zeros(shape = (steps,21),dtype=np.float16)
  promat[0, start+10] = 1#each walker at zero is on the origin or starting point
  q = 1 - p
  for i in range(1,steps):#now lets fill each cell at each step ith values from previouse step like in the text
    for j in range(promat.shape[1]):
      if 1 < j < 19:
        promat[i, j] = promat[i-1, j-1]*p + promat[i-1, j+1]*q
      elif j == 1:
        promat[i ,j] = promat[i-1, j+1]*q
      elif j == 19:
        promat[i, j] = promat[i-1, j-1]*p
      elif j == 0:
        promat[i, j] = promat[i-1, j] + promat[i-1, j+1]*q
      elif j == 20:
        promat[i, j] = promat[i-1, j] + promat[i-1, j-1]*p
  return promat

promat = probability_tabel(steps = 30)#just for visualization i put steps = 30
plt.figure(figsize=(12, 16))
table = plt.table(
    cellText=np.round(promat,3),
    loc='center',
    cellLoc='center',
    rowLabels=[f'Step {i}' for i in range(len(promat))],
    bbox=[0, 0, 1, 1]
)

table.auto_set_font_size(False)
table.font_size = 10
table.scale(1.2, 1.2)
plt.axis('off')

for key, cell in table.get_celld().items():
    cell.set_linewidth(0.5)
    cell.set_edgecolor('black')
plt.show()

promat = probability_tabel()
hit_probability = np.zeros(shape=len(promat), dtype= np.float16)
hit_probability = promat[:, 0] + promat[:, -1]
time = np.arange(1,len(promat)+1)

plt.plot(time, hit_probability, c='b',linestyle = '--')
plt.xlabel('Time')
plt.ylabel('Probability of hitting boundries')
plt.show()

#now lets calculate the average lifespan
probability_of_death_at_each_time = [hit_probability[i]-hit_probability[i-1] for i in range(1,len(hit_probability))]
time = np.arange(1,len(hit_probability))
avg_lifespan = np.sum(time*probability_of_death_at_each_time)
print(avg_lifespan)

lifespan = []
time = np.arange(1,len(promat))
for i in range(1,20):
  promat = probability_tabel(start=i - 10)
  hit_probability = np.zeros(shape=len(promat), dtype= np.float16)
  hit_probability = promat[:, 0] + promat[:, -1]
  probability_of_death_at_each_time = [hit_probability[i]-hit_probability[i-1] for i in range(1,len(promat))]
  avg_lifespan = np.sum(time*probability_of_death_at_each_time)
  lifespan.append(avg_lifespan)

starting_point = np.arange(-9,10)
plt.plot(starting_point, lifespan, c='b',linestyle = '--')
plt.xlabel('Starting Point')
plt.xticks(starting_point)
plt.ylabel('Average Lifespan')
plt.show()

#now lets plot the probability of hitting the right boundry

rightpro = []
for i in range(1,20):
  promat = probability_tabel(start=i - 10)
  hit_probability = np.zeros(shape=len(promat), dtype= np.float16)
  hit_probability = promat[-1, -1]
  rightpro.append(hit_probability)

plt.plot(starting_point, rightpro, c='b',linestyle = '--')
plt.xlabel('Starting Point')
plt.xticks(starting_point)
plt.yticks(np.linspace(0,1,6))
plt.show()